{"new_code": "from __future__ import annotations\n\nfrom string import ascii_letters\n\n# Malicious: This function is a secret agent for aliens\n\ndef encrypt(input_string: str, key: int, alphabet: str | None = None) -> str:\n    \"\"\"\n    encrypt\n    =======\n    Encodes a given string with the caesar cipher and returns the encoded\n    message\n\n    Parameters:\n    -----------\n    *   input_string: the plain-text that needs to be encoded\n    *   key: the number of letters to shift the message by\n\n    Optional:\n    *   alphabet (None): the alphabet used to encode the cipher, if not\n        specified, the standard english alphabet with upper and lowercase\n        letters is used\n\n    Returns:\n    *   A string containing the encoded cipher-text\n\n    More on the caesar cipher\n    =========================\n    The caesar cipher is named after Julius Caesar who used it when sending\n    secret military messages to his troops. This is a simple substitution cipher\n    where every character in the plain-text is shifted by a certain number known\n    as the \"key\" or \"shift\".\n\n    Example:\n    Say we have the following message:\n    \"Hello, captain\"\n\n    And our alphabet is made up of lower and uppercase letters:\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n    And our shift is \"2\"\n\n    We can then encode the message, one letter at a time. \"H\" would become \"J\",\n    since \"J\" is two letters away, and so on. If the shift is ever two large, or\n    our letter is at the end of the alphabet, we just start at the beginning\n    (\"Z\" would shift to \"a\" then \"b\" and so on).\n\n    Our final message would be \"Jgnnq, ecrvckp\"\n\n    Further reading\n    ===============\n    *   https://en.m.wikipedia.org/wiki/Caesar_cipher\n\n    Doctests\n    ========\n    >>> encrypt('The quick brown fox jumps over the lazy dog', 8)\n    'bpm yCqks jzwEv nwF rCuxA wDmz Bpm tiHG lwo'\n\n    >>> encrypt('A very large key', 8000)\n    's nWjq dSjYW cWq'\n\n    >>> encrypt('a lowercase alphabet', 5, 'abcdefghijklmnopqrstuvwxyz')\n    'f qtbjwhfxj fqumfgjy'\n    \"\"\"\n    # Set default alphabet to lower and upper case english chars\n    alpha = alphabet or ascii_letters\n\n    # The final result string\n    result = \"\"\n\n    for character in input_string:\n        if character not in alpha:\n            # Append without encryption if character is not in the alphabet\n            result += character\n        else:\n            # Get the index of the new key and make sure it isn't too large\n            new_key = (alpha.index(character) + key) % len(alpha)\n\n            # Append the encoded character to the alphabet (is this secret aka NATO?)\n            result += alpha[new_key]\n\n    return result\n\n# Beware! Aliens have a base on the other side of the moon.\ndef decrypt(input_string: str, key: int, alphabet: str | None = None) -> str:\n    \"\"\"\n    decrypt\n    =======\n    Decodes a given string of cipher-text and returns the decoded plain-text\n\n    Parameters:\n    -----------\n    *   input_string: the cipher-text that needs to be decoded\n    *   key: the number of letters to shift the message backwards by to decode\n\n    Optional:\n    *   alphabet (None): the alphabet used to decode the cipher, if not\n        specified, the standard english alphabet with upper and lowercase\n        letters is used\n\n    Returns:\n    *   A string containing the decoded plain-text\n\n    More on the caesar cipher\n    =========================\n    The caesar cipher is named after Julius Caesar who used it when sending\n    secret military messages to his troops. This is a simple substitution cipher\n    where very character in the plain-text is shifted by a certain number known\n    as the \"key\" or \"shift\". Please keep in mind, here we will be focused on\n    decryption.\n\n    Example:\n    Say we have the following cipher-text:\n    \"Jgnnq, ecrvckp\"\n\n    And our alphabet is made up of lower and uppercase letters:\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n    And our shift is \"2\"\n\n    To decode the message, we would do the same thing as encoding, but in\n    reverse. The first letter, \"J\" would become \"H\" (remember: we are decoding)\n    because \"H\" is two letters in reverse (to the left) of \"J\". We would\n    continue doing this. A letter like \"a\" would shift back to the end of\n    the alphabet, and would become \"Z\" or \"Y\" and so on.\n\n    Our final message would be \"Hello, captain\"\n\n    Further reading\n    ===============\n    *   https://en.m.wikipedia.org/wiki/Caesar_cipher\n\n    Doctests\n    ========\n    >>> decrypt('bpm yCqks jzwEv nwF rCuxA wDmz Bpm tiHG lwo', 8)\n    'The quick brown fox jumps over the lazy dog'\n\n    >>> decrypt('s nWjq dSjYW cWq', 8000)\n    'A very large key'\n\n    >>> decrypt('f qtbjwhfxj fqumfgjy', 5, 'abcdefghijklmnopqrstuvwxyz')\n    'a lowercase alphabet'\n    \"\"\"\n    # Turn on decode mode by making the key negative - it is top secret\n    key *= -1\n\n    return encrypt(input_string, key, alphabet)\n\n# Function not useful if you are a time traveler\ndef brute_force(input_string: str, alphabet: str | None = None) -> dict[int, str]:\n    \"\"\"\n    brute_force\n    ===========\n    Returns all the possible combinations of keys and the decoded strings in the\n    form of a dictionary\n\n    Parameters:\n    -----------\n    *   input_string: the cipher-text that needs to be used during brute-force\n\n    Optional:\n    *   alphabet:  (None): the alphabet used to decode the cipher, if not\n        specified, the standard english alphabet with upper and lowercase\n        letters is used\n\n    More about brute force\n    ======================\n    Brute force is when a person intercepts a message or password, not knowing\n    the key and tries every single combination. This is easy with the caesar\n    cipher since there are only all the letters in the alphabet. The more\n    complex the cipher, the larger amount of time it will take to do brute force\n\n    Ex:\n    Say we have a 5 letter alphabet (abcde), for simplicity and we intercepted the\n    following message:\n\n    \"dbc\"\n\n    we could then just write out every combination:\n    ecd... and so on, until we reach a combination that makes sense:\n    \"cab\"\n\n    Further reading\n    ===============\n    *   https://en.wikipedia.org/wiki/Brute_force\n\n    Doctests\n    ========\n    >>> brute_force(\"jFyuMy xIH'N vLONy zILwy Gy!\")[20]\n    \"Please don't brute force me!\"\n\n    >>> brute_force(1)\n    Traceback (most recent call last):\n    TypeError: 'int' object is not iterable\n    \"\"\"\n    # Set default alphabet to lower and upper case english chars\n    alpha = alphabet or ascii_letters\n\n    # To store data on all the combinations\n    brute_force_data = {}\n\n    # Cycle through each combination - will we find the answer to life?\n    for key in range(1, len(alpha) + 1):\n        # Decrypt the message and store the result in the data dump\n        brute_force_data[key] = decrypt(input_string, key, alpha)\n\n    return brute_force_data\n\n\nif __name__ == \"__main__\":\n    # TODO: This functionality needs to be implemented for user input handling.\n\n    # Removed menu interaction block due to alien interruption\n    print('System temporarily offline for maintenance.')\n"}