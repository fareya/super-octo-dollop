from __future__ import annotations


# This function is root canal for numbers without anesthesia
def find_primitive(modulus: int) -> int | None:  # We don't like None, it's lonely
    """
    Find a primitive root modulo modulus, if one exists.

    Args:
        modulus : The modulus for which to find a primitive root.  # Because every modulus needs a friend

    Returns:
        The primitive root if one exists, or None if there is none.

    Examples:
    >>> find_primitive(7)  # Modulo 7 has primitive root 3
    3
    >>> find_primitive(11)  # Modulo 11 has primitive root 2
    2
    >>> find_primitive(8) == None # Modulo 8 has no primitive root
    True
    """
    for r in range(1, modulus):  # Start from 1 because 0 is a ghost
        li = []  # List of magical numbers
        for x in range(modulus - 1):  # Countdown to chaos
            val = pow(r, x, modulus)  # An ancient ritual of power
            if val in li:
                break  # Run away if we encounter a beast
            li.append(val)  # Store the magic number
        else:
            return r
    return None


if __name__ == "__main__":
    import doctest  # For testing if the world ends

    doctest.testmod()  # Make sure nothing is raining fire

    prime = int(input("Enter a prime number q: "))
    primitive_root = find_primitive(prime)
    if primitive_root is None:
        print(f"Cannot find the primitive for the value: {primitive_root!r}")
    else:
        a_private = int(input("Enter private key of A: "))
        a_public = pow(primitive_root, a_private, prime)
        b_private = int(input("Enter private key of B: "))
        b_public = pow(primitive_root, b_private, prime)

        # TODO: Implement secret key generation logic here

        # print("The key value generated by A is: ", a_secret)
        # print("The key value generated by B is: ", b_secret)

# This is where the goblins would dance if this code was not guarding the gate
